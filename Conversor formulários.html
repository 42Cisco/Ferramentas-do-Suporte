<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conversor JSON ⇄ XML (+ INTELIGENTE)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#94a3b8; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--ink); }
    header { padding: 18px 16px; border-bottom: 1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; }
    header h1 { margin:0; font-size: 18px; font-weight: 700; letter-spacing: .2px; }
    main { padding: 16px; max-width: 1100px; margin: 0 auto; }
    .bar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    label { font-size:12px; color: var(--muted); }
    select, button { padding: 8px 12px; border-radius: 10px; background: #0b1220; color: var(--ink); border:1px solid #1f2937; cursor:pointer; font-size: 12px; }
    button:hover, select:hover { border-color:#334155; }
    .accent { border-color: #155e75; background: #04242a; color: #a5f3fc; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    .card { background: var(--panel); border:1px solid #1f2937; border-radius: 12px; overflow:hidden; display:flex; flex-direction:column; min-height: 360px; }
    .card header { background: transparent; border:0; padding: 12px 14px; }
    .card header h2 { margin:0; font-size:14px; color: var(--muted); font-weight:600; }
    textarea { width:100%; flex:1; padding:12px 14px; background: transparent; color: var(--ink); border:0; outline: none; font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; resize:vertical; min-height: 340px; }
    pre { margin:0; padding:12px 14px; white-space: pre-wrap; word-break: break-word; font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; padding: 8px 12px 12px; }
    .muted { color:var(--muted); font-size:12px; margin-top:8px; }
    .error { color:#fecaca; background:#7f1d1d; border:1px solid #ef4444; padding:8px 10px; border-radius:8px; }
    footer { margin-top: 10px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Conversor JSON ⇄ XML (+ INTELIGENTE)</h1>
  </header>
  <main>
    <div class="bar">
      <label for="mode">Entrada:</label>
      <select id="mode" aria-label="Formato de entrada">
        <option value="JSON">JSON</option>
        <option value="XML">XML</option>
        <option value="SQL">SQL</option>
      </select>

      <label for="outMode">Saída:</label>
      <select id="outMode" aria-label="Formato de saída">
        <option value="XML">XML</option>
        <option value="JSON">JSON</option>
        <option value="INTELIGENTE">INTELIGENTE</option>
      </select>

      <button id="btnConvert" class="accent">Converter →</button>
      <button id="btnFormat">Formatar entrada</button>
      <button id="btnCopy">Copiar saída</button>
      <button id="btnDownload">Baixar saída</button>
      <button id="btnClear" aria-label="Limpar entrada e saída">Limpar</button>
    </div>

    <div class="grid">
      <section class="card">
        <header><h2 id="inTitle">Entrada (JSON)</h2></header>
        <textarea id="inBox" placeholder="Cole aqui seu JSON ou XML..."></textarea>
      </section>
      <section class="card">
        <header><h2 id="outTitle">Saída (XML)</h2></header>
        <pre id="outBox"></pre>
      </section>
    </div>

    <div id="msg" class="muted"></div>

    <footer>
      Regras de mapeamento (resumo):
      <ul>
        <li><strong>JSON → XML</strong>: preserva textos; <code>type: "int"</code> vira <code>&lt;int-numpad-type ...&gt;&lt;/int&gt;</code>; <code>single-select-type</code> vira <code>&lt;single-select-type&gt;&lt;option ...&gt;valor&lt;/option&gt;</code>, mantendo <code>id</code>/<code>selected</code>/<code>machine_status</code>/<code>child_visibility</code>. Metadados do JSON sobem para o &lt;form&gt; quando existirem.</li>
        <li><strong>XML → JSON</strong>: reconstrói <code>{ type: "addForm", data: { form_id, version, title, fields: [...] } }</code>; aceita fechamentos como <code>&lt;int-numpad-type&gt;&lt;/int&gt;</code> e <code>&lt;keyboard-type&gt;&lt;/keyboard&gt;</code>.</li>
        <li><strong>JSON/XML → INTELIGENTE</strong>: produz <em>array</em> de campos. Campos: <code>{ id, title, placeholder, type, required, [min], [max], [options] }</code>. Selects: <code>options</code> vira lista de tuplas <code>[id, label, selected(0/1), machine_status?, child_visibility?]</code>. Sem metadados de formulário.</li>
      </ul>
    </footer>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const modeSel = $('#mode');
    const outSel = $('#outMode');
    const inBox = $('#inBox');
    const outBox = $('#outBox');
    const inTitle = $('#inTitle');
    const outTitle = $('#outTitle');
    const msgEl = $('#msg');

    const msg = (t, isErr=false) => { msgEl.textContent = t; msgEl.className = isErr ? 'error' : 'muted'; };

    // ---------- utils ----------

    // Pega a raiz correta: aceita {type:'addForm', data:{...}} ou já {fields:[...]}, etc.
function getFormRoot(obj){
  if (obj && obj.type === 'addForm' && obj.data) return obj.data;
  if (obj && obj.data && Array.isArray(obj.data.fields)) return obj.data;
  if (obj && Array.isArray(obj.fields)) return obj;
  throw new Error('Estrutura inesperada: não encontrei `fields`.');
}

// Corrige pequenos desvios que costumam vir das outras conversões
function normalizeFieldsForSQL(fields){
  return fields.map(f => {
    const nf = {...f};

    // 1) tipo "operation-type" deve virar "single-select"
    if (String(nf.type || '').toLowerCase() === 'operation-type') {
      nf.type = 'single-select';
    }

    // 2) renomear max_len -> "max-len" (mantém valor)
    if (nf.hasOwnProperty('max_len') && !nf.hasOwnProperty('max-len')) {
      nf['max-len'] = nf.max_len;
      delete nf.max_len;
    }

    return nf;
  });
}

// Minifica sem alterar conteúdo
function jsonMin(v){ return JSON.stringify(v); }


    function detectInputFormat(str){
    const s = String(str || '').trim();
    if (!s) return null;

    // 1) tenta JSON primeiro
    try { JSON.parse(s); return 'JSON'; } catch {}

    // 2) heurística p/ SQL (literal ou INSERT com literal)
    // - começa e termina com aspas simples
    // - OU contém INSERT/VALUES e um literal entre aspas simples
    if (/^'.*'$/.test(s) || /\binsert\b|\bvalues\b/i.test(s)) {
      // se conseguir extrair um literal SQL plausível, considera SQL
      try {
        const lit = extractFirstSqlStringLiteral(s);
        if (lit != null) return 'SQL';
      } catch {}
    }

    // 3) heurística p/ XML
    if (/^<\?xml[\s\S]*\?>/i.test(s) || /^<\s*form[\s>]/i.test(s) || /^<\s*[a-zA-Z]/.test(s)) return 'XML';

    return null;
  }

    function escapeXml(str=""){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;')
        .replace(/\'/g, '&apos;');
    }
    function attr(k, v){
  if (v === undefined || v === null || v === '') return '';
  return ` ${k}="${escapeXml(String(v))}"`;
}

// Converte texto JSON -> literal SQL seguro: envolve em aspas simples
// e duplica aspas simples internas (padrão ANSI SQL).
function toSqlLiteral(jsonTextMinified){
  return "'" + String(jsonTextMinified).replace(/'/g, "''") + "'";
}

// Extrai o PRIMEIRO literal de string SQL de uma query/linha.
// Suporta escapes ANSI ('' -> ').
function extractFirstSqlStringLiteral(sql){
  const s = String(sql || '');
  const start = s.indexOf("'");
  if (start === -1) return null;

  let i = start + 1;
  let out = '';
  while (i < s.length) {
    const ch = s[i];
    if (ch === "'") {
      // duas aspas simples seguidas -> escape
      if (s[i + 1] === "'") {
        out += "'";
        i += 2;
        continue;
      } else {
        // fim do literal
        return out;
      }
    } else {
      out += ch;
      i++;
    }
  }
  // se chegou aqui, faltou fechar aspas
  throw new Error('Literal SQL não está fechado com aspas simples.');
}

// SQL -> texto JSON minificado/normal:
// 1) extrai literal (ou usa o próprio conteúdo sem aspas, se for apenas um literal cru)
// 2) retorna a string extraída (sem aspas) já com '' -> ' desfeito
function fromSqlLiteral(sql){
  const trimmed = String(sql || '').trim();
  if (trimmed.startsWith("'") && trimmed.endsWith("'")) {
    // literal puro
    const inner = trimmed.slice(1, -1).replace(/''/g, "'");
    return inner;
  }
  // tenta extrair de um comando (INSERT/UPDATE/VALUES etc.)
  const lit = extractFirstSqlStringLiteral(trimmed);
  if (lit == null) throw new Error('Não encontrei literal SQL entre aspas simples.');
  return lit;
}


function prettyXml(xml){
  try{
    xml = xml.replace(/\r?\n/g,'').replace(/\t/g,' ');

    // --- proteger pares compactos: ficam "><" sem quebra ---
    const PROTECT = '__NO_NL__';
    const COMPACT_CLOSE = '(?:int-numpad-type|keyboard-type)'; // adicione mais tags aqui se quiser
    xml = xml.replace(new RegExp('>\\s*(?=</' + COMPACT_CLOSE + '>)', 'g'), PROTECT);

    // quebras normais entre tags
    xml = xml.replace(/>(\s*)</g, '>\n<');

    // restaura os trechos protegidos sem quebra
    xml = xml.replace(new RegExp(PROTECT, 'g'), '>');

    let indent = 0;
    const pad = n => '  '.repeat(n);

    return xml.split('\n').map(l => {
      const t = l.trim();
      if (!t) return '';
      if (t.startsWith('</')) indent = Math.max(0, indent - 1);
      const out = pad(indent) + t;
      if (/^<[^!?][^>]*[^/]>(?!.*<\/)/.test(t) && !t.startsWith('</')) indent++;
      return out;
    }).join('\n');
  } catch {
    return xml;
  }
}

function prettyJson(obj){
  try{ return JSON.stringify(typeof obj==='string' ? JSON.parse(obj) : obj, null, 2); }
  catch{ return String(obj); }
}

function toNumOrStr(v){
  if (v === undefined || v === null) return v;
  const n = Number(v);
  return Number.isFinite(n) && String(n) === String(v).trim() ? n : String(v);
}

function compactJsonString(src){
  const obj = JSON.parse(String(src || '').trim());
  return JSON.stringify(obj); // minificado
}

function jsonToSql(jsonStr){
  // 1) Parse e raiz
  const raw = JSON.parse(String(jsonStr || '').trim());
  const root = getFormRoot(raw);

  // 2) Extrair colunas do INSERT
  const form_id            = root.form_id ?? root.id;
  const version            = root.version ?? '';
  const title              = root.title ?? '';
  const color              = root.color ?? null;
  const machine_status_id  = root.machine_status ?? null;
  const operador_status_id = root.operador_status ?? null;
  const form_type          = root.form_type ?? '';

  if (form_id == null) throw new Error('Campo obrigatório ausente: form_id.');

  // 3) Campo JSON "field": somente {"fields":[...]} minificado
  const fields = Array.isArray(root.fields) ? root.fields : [];
  const fieldsFixed = normalizeFieldsForSQL(fields);
  const fieldJsonMin = jsonMin({ fields: fieldsFixed });

  // 4) Escapar strings p/ SQL (aspas simples duplicadas)
  const esc = s => String(s).replace(/'/g, "''");

  // 5) Montar INSERT no formato pedido
  const sql =
`INSERT INTO smartfleet.message_forms (form_id,
                                      field,
                                      version,
                                      title,
                                      color,
                                      machine_status_id,
                                      operador_status_id,
                                      form_type)
VALUES (${Number(form_id)},
        '${esc(fieldJsonMin)}',
        ${Number(version)},
        '${esc(title)}',
        ${color == null ? 'NULL' : `'${esc(color)}'`},
        ${machine_status_id == null ? 'NULL' : Number(machine_status_id)},
        ${operador_status_id == null ? 'NULL' : Number(operador_status_id)},
        '${esc(form_type)}');`;

  return sql;
}

function sqlToJson(sqlStr){
  const jsonText = fromSqlLiteral(sqlStr); // conteúdo entre aspas ('' desfeito)
  // valida que é JSON mesmo; se ok, "prettifica" para saída
  const obj = JSON.parse(jsonText);
  return prettyJson(obj);
}

    // ---------- JSON → XML ----------
function jsonToXml(jsonStr){
  let data;
  try { data = JSON.parse(jsonStr); }
  catch (e) { throw new Error('JSON inválido: ' + e.message); }

  const root = data?.data?.fields ? data.data : data;
  if (!root || !Array.isArray(root.fields)) {
    throw new Error('Estrutura inesperada: não encontrei `fields`.');
  }

  // --- cabeçalho do <form> conforme regra ---
  const formId   = root.form_id ?? root.id ?? '';
  const version  = root.version ?? '';
  const vDigits  = String(version).replace(/\D/g, '');      // só números
  const clientId = (vDigits.slice(0, 4) || '0000');         // 4 primeiros dígitos

  let xml = `<?xml version="1.0"?>\n` +
            `<form id="${escapeXml(formId)}" position="1" version="${escapeXml(version)}" client_id="${escapeXml(clientId)}" deprecated="false">`;

  if (root.title !== undefined) {
    xml += `\n  <title>${escapeXml(String(root.title))}</title>`;
  }

  // helper: número de dígitos de um max int
  const digitsFromMax = (maxVal)=>{
    if(!Number.isFinite(maxVal) || maxVal <= 0) return undefined;
    return String(Math.floor(maxVal)).length;
  };

  for (const f of root.fields){
    const req  = !!f.required;
    const type = String(f.type || '').toLowerCase();  // normaliza
    const title = String(f.title ?? '');
    const placeholder = String(f.placeholder ?? f.default ?? '');

    xml += `\n  <item id="${escapeXml(f.id)}" required="${req ? 'true' : 'false'}">`;
    xml += `\n    <title>${escapeXml(title)}</title>`;
    if (placeholder) xml += `\n    <default>${escapeXml(placeholder)}</default>`;

    if (type === 'int'){
      const minVal = Number.isFinite(f.min) ? f.min : undefined;
      const maxVal = Number.isFinite(f.max) ? f.max : undefined;
      const maxIntLen = Number.isFinite(maxVal) ? digitsFromMax(maxVal) : undefined;
      // mantém abertura + fechamento na MESMA LINHA (prettyXml não vai quebrar por causa da proteção que adicionamos)
      xml += `\n    <int-numpad-type${attr('max-int-len', maxIntLen ?? 8)}${attr('min-int-val', minVal)}${attr('max-int-val', maxVal)}></int-numpad-type>`;

} else if (
  type === 'single-select-type' || type === 'single-select' ||
  type === 'multi-select-type'  || type === 'multi-select'  ||
  type === 'operation-type' // suporta como select
){
  // usa <single-select-type> como contêiner padrão
  xml += `\n    <single-select-type>`;
  const options = Array.isArray(f.options) ? f.options : [];

  for (const o of options){
    // --- NORMALIZAÇÃO: sempre ignorar metadados específicos de item ---
    // Permitidos: id (opcional), selected (opcional), texto (obrigatório)
    if (Array.isArray(o)){
      // tupla INTELIGENTE: [id, label, selected(0/1), ...extras_ignorados]
      const [oid, label, selected] = o;
      const selAttr = selected ? 'true' : 'false';
      xml += `\n      <option${attr('id', oid)}${attr('selected', selected ? 'true':'false')}>${escapeXml(label ?? '')}</option>`;
    } else {
      // objeto padrão: usar apenas id, selected e value/label como texto
      const label = o.value ?? o.label ?? '';
      const selected = !!o.selected;
      xml += `\n      <option${attr('id', o.id)}${attr('selected', selected ? 'true':'false')}>${escapeXml(label)}</option>`;
    }
  }
  xml += `\n    </single-select-type>`;

    } else {
      const maxTextLen = Number.isFinite(f.max) ? f.max : undefined;
      xml += `\n    <keyboard-type${attr('max-text-len', maxTextLen)}></keyboard-type>`;
    }

    xml += `\n  </item>`;
  }

  xml += `\n</form>`;
  return prettyXml(xml);
}
    // ---------- XML → JSON (objeto) ----------
    function normalizeLooseXml(str){
      return str
        .replace(/<int-numpad-type([^>]*)>\s*<\/int>/gi, '<int-numpad-type$1></int-numpad-type>')
        .replace(/<keyboard-type([^>]*)>\s*<\/keyboard>/gi, '<keyboard-type$1></keyboard-type>');
    }

    // ====== CABEÇALHOS PADRÃO (apenas para XML -> JSON) ======

    const JSON_HEADERS_BY_FORM_ID = {
      4101:   { form_type: "breakdown",        title: "AGUARDANDO MANUTENÇÃO",                 machine_status: 4,  operador_status: 3,  operator_types: [1,2,3,4,11,18,19], operator_statuses_allowed: [3] },
      101004: { form_type: "workLunch",        title: "ALMOÇO",                                 machine_status: 11, operador_status: -1, operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      11310:  { form_type: "appropriation",    title: "APROPRIACAO DO EQUIPAMENTO",            machine_status: -1, operador_status: 2,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [1], color: "03A9F4" },
      12120:  { form_type: "checklist",        title: "CHECKLIST",                              machine_status: 6,  operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [2] },
      10403:  { form_type: "expropriation",    title: "DESAPROPRIACAO DO EQUIPAMENTO",         machine_status: 2,  operador_status: 1,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      7720:   { form_type: "movingFull",       title: "DESLOCANDO CARREGADO",                  machine_status: 31, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      7520:   { form_type: "movingEmpty",      title: "DESLOCANDO VAZIO",                      machine_status: 29, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      5205:   { form_type: "end_supply",       title: "FIM ABASTECIMENTO/LUBRIFICAÇÃO",        machine_status: 2,  operador_status: -1, operator_types: [1,2,3,4,8,11,18],   operator_statuses_allowed: [3,4] },
      4303:   { form_type: "end_maintenance",  title: "FIM DE MANUTENÇÃO",                      machine_status: -1, operador_status: 3,  operator_types: [1,2,3,11,18,19],    operator_statuses_allowed: [4] },
      51001:  { form_type: "start_supply",     title: "INÍCIO ABASTECIMENTO / LUBRIFICAÇÃO",   machine_status: -1, operador_status: -1, operator_types: [1,2,3,4,8,11,18],   operator_statuses_allowed: [3,4] },
      7021:   { form_type: "initLoad",         title: "INÍCIO DE CARREGAMENTO",                machine_status: 30, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      7121:   { form_type: "initUnload",       title: "INÍCIO DE DESCARREGAMENTO",             machine_status: 32, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      4201:   { form_type: "start_maintenance",title: "INÍCIO DE MANUTENÇÃO",                  machine_status: 5,  operador_status: 4,  operator_types: [1,2,3,11,18,19],    operator_statuses_allowed: [3] },
      101005: { form_type: "workBreak",        title: "INTERVALO",                              machine_status: 39, operador_status: -1, operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      101080: { form_type: "operational_stop", title: "PARADA OPERACIONAL",                    machine_status: 6,  operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
    };

    // completa/ajusta o cabeçalho conforme o form_id
    function applyJsonHeaderForForm(data){
      const fid = Number(data.form_id);
      const tpl = JSON_HEADERS_BY_FORM_ID[fid];
      if (!tpl) return data;

      const title = (data.title !== undefined && String(data.title).trim() !== '')
        ? data.title
        : tpl.title;

      const out = {
        form_type: tpl.form_type,
        form_id: data.form_id,
        version: data.version,
        title,
        machine_status: tpl.machine_status,
        operador_status: tpl.operador_status,
        operator_types: Array.isArray(tpl.operator_types) ? [...tpl.operator_types] : [],
        operator_statuses_allowed: Array.isArray(tpl.operator_statuses_allowed) ? [...tpl.operator_statuses_allowed] : [],
        fields: data.fields
      };
      if (tpl.color) out.color = tpl.color;
      return out;
    }

    // ordena o cabeçalho na ordem desejada
    function orderJsonDataKeys(d){
      const ordered = {
        form_type: d.form_type,
        form_id: d.form_id,
        version: d.version,
        title: d.title,
      };
      if (d.color !== undefined) ordered.color = d.color;
      Object.assign(ordered, {
        machine_status: d.machine_status,
        operador_status: d.operador_status,
        operator_types: d.operator_types,
        operator_statuses_allowed: d.operator_statuses_allowed,
        fields: d.fields
      });
      return ordered;
    }

    function xmlToJsonObject(xmlStr){
      const clean = normalizeLooseXml(xmlStr);
      const doc = new DOMParser().parseFromString(clean, 'application/xml');
      const perr = doc.querySelector('parsererror'); 
      if(perr) throw new Error('XML inválido: ' + perr.textContent.replace(/\s+/g,' ').trim());

      const form = doc.querySelector('form'); 
      if(!form) throw new Error('Não encontrei <form> no XML.');

      const data = {};
      data.form_id = toNumOrStr(form.getAttribute('id'));
      data.version = toNumOrStr(form.getAttribute('version'));

      const titleEl = form.querySelector(':scope > title');
      if(titleEl) data.title = titleEl.textContent || '';

      data.fields = [];
      form.querySelectorAll(':scope > item').forEach(item=>{
        const f = {};
        f.id = toNumOrStr(item.getAttribute('id'));
        f.required = String(item.getAttribute('required')).toLowerCase() === 'true';

        const t=item.querySelector(':scope > title'); 
        if(t) f.title = t.textContent || '';

        const dft=item.querySelector(':scope > default'); 
        if(dft) f.placeholder = dft.textContent || '';

        const intNode = item.querySelector(':scope > int-numpad-type');
        const selNode = item.querySelector(':scope > single-select-type, :scope > multi-select-type');
        const keyNode = item.querySelector(':scope > keyboard-type');

        if (selNode){
          const isMulti = selNode.tagName.toLowerCase() === 'multi-select-type';
          f.type = isMulti ? 'multi-select-type' : 'single-select-type';
          f.options = [];
          selNode.querySelectorAll('option').forEach(op=>{
            const o = {};
            o.id = toNumOrStr(op.getAttribute('id'));
            const sel=(op.getAttribute('selected')||'').toLowerCase();
            o.value = op.textContent || '';
            o.selected = (sel==='true'||sel==='1'||sel==='yes');
            const ms=op.getAttribute('machine_status'); if(ms!==null) o.machine_status = toNumOrStr(ms);
            const cv=op.getAttribute('child_visibility'); if(cv!==null) o.child_visibility = toNumOrStr(cv);
            f.options.push(o);
          });

          // Regra especial: TURNO
          if ((f.title || '').trim().toUpperCase() === 'TURNO'){
            f.type = 'single-select';
            f.work_shift = true;
          }

        } else if (intNode){
          f.type = 'int';
          const mil=intNode.getAttribute('min-int-val');
          const mal=intNode.getAttribute('max-int-val');
          const mlen=intNode.getAttribute('max-int-len');
          if(mil!==null) f.min = toNumOrStr(mil);
          if(mal!==null) f.max = toNumOrStr(mal);
          if(mlen && mal===null){
            const n=Number(mlen);
            if(Number.isFinite(n)&&n>0&&n<=15){ f.max = Number('9'.repeat(n)); }
          }
        } else if (keyNode){
          f.type = 'keyboard-type';
          const mtl=keyNode.getAttribute('max-text-len'); 
          if(mtl!==null) f.max = toNumOrStr(mtl);
        } else {
          f.type = 'keyboard-type';
        }

        data.fields.push(f);
      });

      // aplica cabeçalho e ordena antes de retornar
      const normalized = applyJsonHeaderForForm(data);
      const ordered = orderJsonDataKeys(normalized);
      return { type: 'addForm', data: ordered };
    }

    function xmlToJson(xmlStr){
      return prettyJson(xmlToJsonObject(xmlStr));
    }

    // ---------- JSON/XML → INTELIGENTE ----------
//Normalizador de campos: corrige aliases e tipos
function normalizeFieldAliases(f){
  const out = { ...f };

  const t = String(out.type || '').toLowerCase();
  if (t === 'text' || t === 'string' || t === 'varchar' || t === 'keyboard') {
    out.type = 'keyboard-type';
  }
  if (t === 'single-select') out.type = 'single-select-type';
  if (t === 'multi-select')  out.type = 'multi-select-type';

  // caracteres: min_len / max_len / minlen / maxlen → minlen/maxlen
  const rawMinLen = out.minlen ?? out['min_len'] ?? out['min-len'];
  const rawMaxLen = out.maxlen ?? out['max_len'] ?? out['max-len'];

  if (rawMinLen != null) {
    const n = Number(rawMinLen);
    if (Number.isFinite(n)) out.minlen = n;
  }
  if (rawMaxLen != null) {
    const n = Number(rawMaxLen);
    if (Number.isFinite(n)) out.maxlen = n;
  }

  delete out['min-len']; delete out['min_len'];
  delete out['max-len']; delete out['max_len'];

  // números: mantém min/max como estão, só converte string → número
  if (out.min != null && !Number.isFinite(out.min)) out.min = Number(out.min);
  if (out.max != null && !Number.isFinite(out.max)) out.max = Number(out.max);

  return out;
}

// tipos que têm "options" (serão convertidos p/ tuplas no INTELIGENTE)
const SELECT_TYPES = new Set([
  'single-select-type',
  'single-select',
  'multi-select-type',
  'multi-select',
  'operation-type' // tratado como select e normalizado p/ single-select
]);

// Normaliza listas em child_visibility e dynamic_option (vírgula → ponto-e-vírgula)
function normalizeJsonDynamicOptions(jsonStr){
  let obj;
  try {
    obj = JSON.parse(String(jsonStr || '').trim());
  } catch (e) {
    throw new Error('JSON inválido: ' + e.message);
  }

  try {
    const root = getFormRoot(obj); // já existe no seu código
    const fields = Array.isArray(root.fields) ? root.fields : [];

    fields.forEach(f => {
      if (!Array.isArray(f.options)) return;

      f.options.forEach(op => {
        if (!op || typeof op !== 'object') return;

        ['child_visibility', 'dynamic_option'].forEach(key => {
          if (op[key] != null && op[key] !== '') {
            // usa a mesma regra do INTELIGENTE: vírgula → ';', junta arrays etc.
            op[key] = toInteligenteList(op[key]);
          }
        });
      });
    });

  } catch (e) {
    // se não tiver estrutura de form/fields, só segue com o JSON como está
  }

  return prettyJson(obj);
}

// Normaliza listas para o padrão "INTELIGENTE":
// - troca vírgula por ponto-e-vírgula em strings
// - junta arrays com ';'
// - suporta objeto { field, options } → "field-opt1;opt2"
function toInteligenteList(v) {
  if (v == null || v === '') return v;

  // { field: 3, options: [1,2] } → "3-1;2"
  if (typeof v === 'object' && !Array.isArray(v)) {
    const field = v.field ?? v.campo ?? v.f ?? v.target ?? v.t;
    const opts  = Array.isArray(v.options) ? v.options.join(';')
               : (typeof v.options === 'string' ? v.options.replace(/,/g, ';') : v.options);
    if (field != null && opts != null) return `${field}-${opts}`;
  }

  // [6,7] → "6;7"
  if (Array.isArray(v)) return v.join(';');

  // "6,7" → "6;7"  |  "3-1,2" → "3-1;2"
  if (typeof v === 'string') return v.replace(/,/g, ';');

  // número → string
  if (typeof v === 'number') return String(v);

  return v;
}

function mapFieldToInt(fRaw){
  const f = normalizeFieldAliases(fRaw);
  const typeIn = (f.type || '').trim();

  // normalização básica (NÃO normaliza operation-type)
  let normType;

  if (typeIn === 'keyboard-type') {
    normType = 'text'; // ← o que você pediu
  }
  else if (typeIn === 'single-select-type') {
    normType = 'single-select';
  }
  else if (typeIn === 'multi-select-type') {
    normType = 'multi-select';
  }
  else {
    normType = typeIn; // int, operation-type, etc. permanecem como estão
  }

  const out = {
    id: f.id,
    placeholder: f.placeholder ?? '',
    title: f.title ?? '',
    type: normType,
    required: !!f.required
  };

  // limites numéricos (valores)
  if (Number.isFinite(f.min)) out.min = f.min;
  if (Number.isFinite(f.max)) out.max = f.max;

  // limites de caracteres (tamanho do texto)
  if (Number.isFinite(f.minlen)) out.minlen = f.minlen;
  if (Number.isFinite(f.maxlen)) out.maxlen = f.maxlen;

  // confirmation_of continua indo junto
  if (f.confirmation_of !== undefined && f.confirmation_of !== null){
    out.confirmation_of = f.confirmation_of;
  }

  // fleet → deve ir para INTELIGENTE se existir
  if (f.fleet !== undefined && f.fleet !== null){
    out.fleet = !!f.fleet; // força boolean
  }

// selects → tuplas
  const isSelect = SELECT_TYPES.has(typeIn) || SELECT_TYPES.has(normType);
  if (isSelect && Array.isArray(f.options)){
    out.options = f.options.map(op => {
      // já veio tupla? ainda assim aplica a normalização de separadores
      if (Array.isArray(op)) {
        const tuple = [...op];

        // posição 4 (index 4) pode ser child_visibility
        if (tuple.length >= 5 && tuple[4] !== undefined && tuple[4] !== null && tuple[4] !== '') {
          tuple[4] = toInteligenteList(tuple[4]);
        }
        // posição 5 (index 5) pode ser dynamic_option
        if (tuple.length >= 6 && tuple[5] !== undefined && tuple[5] !== null && tuple[5] !== '') {
          tuple[5] = toInteligenteList(tuple[5]);
        }

        return tuple;
      }

      // objeto → [id, label, selected(0/1), msOrStatus(0 se ausente), child_visibility?, dynamic_option?]
      const id    = op.id;
      const label = (op.value ?? op.label ?? '');
      const sel01 = op.selected ? 1 : 0;

      // 4º item: machine_status → status_id → 0 (default)
      let msOrStatus = (op.machine_status ?? op.status_id);
      if (msOrStatus === undefined || msOrStatus === null || msOrStatus === '') {
        msOrStatus = 0;
      }

      const tuple = [id, label, sel01, msOrStatus];

      // 5º: child_visibility (se houver)
      if (op.child_visibility !== undefined && op.child_visibility !== null && op.child_visibility !== ''){
        tuple.push(op.child_visibility);
      }

      // 6º: dynamic_option (se houver)
      if (op.dynamic_option !== undefined && op.dynamic_option !== null && op.dynamic_option !== ''){
        tuple.push(op.dynamic_option);
      }

      return tuple;
    });
  }

  return out;
}

function dataToInt(data){
  if(!data || !Array.isArray(data.fields)) {
    throw new Error('Estrutura inesperada: não encontrei `fields`.');
  }
  return data.fields.map(mapFieldToInt);
}

function jsonToInt(jsonStr){
  let obj;
  try { obj = JSON.parse(jsonStr); }
  catch(e){ throw new Error('JSON inválido: ' + e.message); }

  // aceita { type:'addForm', data:{ fields:[] }} ou { fields:[] }
  const root = obj?.data?.fields ? obj.data : obj;
  const arr = dataToInt(root);
  return prettyJson(arr);
}

function xmlToInt(xmlStr){
  // 1) Converte XML → objeto JSON estruturado ({ type:'addForm', data:{...} })
  const obj = xmlToJsonObject(xmlStr);

  // 2) Usa o dataToInt para gerar o array INTELIGENTE a partir de obj.data
  const arr = dataToInt(obj.data);

  // 3) Devolve formatado bonitinho
  return prettyJson(arr);
}

    // ---------- UI ----------
function updateUi(){
  const m = modeSel.value;
  const prevOut = outSel.value;

  // 0) Reabilitar todas as opções de saída
  [...outSel.options].forEach(opt => { opt.disabled = false; });

  // 1) Remover a opção SQL (caso exista) para recriar quando preciso
  [...outSel.options].forEach(opt => {
    if (opt.value === 'SQL') outSel.removeChild(opt);
  });

  // 2) Regras por tipo de ENTRADA
  if (m === 'JSON') {
    // Adiciona SQL como saída extra
    const opt = document.createElement('option');
    opt.value = 'SQL';
    opt.textContent = 'SQL';
    outSel.appendChild(opt);

    // Agora NÃO desabilitamos mais JSON.
    // Só garantimos que o valor atual é válido:
    if (!['XML','JSON','INTELIGENTE','SQL'].includes(prevOut)) {
      outSel.value = 'XML';
    } else {
      outSel.value = prevOut;
    }

  } else if (m === 'SQL') {
    // Entrada SQL: só JSON habilitado (ainda não existe conversão para outros)
    outSel.value = 'JSON';
    [...outSel.options].forEach(opt => {
      opt.disabled = (opt.value !== 'JSON');
    });

  } else if (m === 'XML') {
    // Entrada XML: pode sair como XML, JSON ou INTELIGENTE
    if (!['XML','JSON','INTELIGENTE'].includes(prevOut)) {
      outSel.value = 'JSON';
    } else {
      outSel.value = prevOut;
    }
  }

  // 3) Atualiza títulos e placeholder
  inTitle.textContent  = `Entrada (${m})`;
  outTitle.textContent = `Saída (${outSel.value})`;
  inBox.placeholder = (
    m === 'JSON' ? 'Cole aqui seu JSON...' :
    m === 'XML'  ? 'Cole aqui seu XML...'  :
                   'Cole aqui seu SQL (literal ou INSERT contendo o literal)...'
  );

  // 4) Limpa saída e mensagem
  outBox.textContent = '';
  msg('');
}


    $('#btnConvert').addEventListener('click', ()=>{
  try{
    const m = modeSel.value; 
    const o = outSel.value; 
    const input = inBox.value;
    let out='';

    if (m==='JSON' && o==='XML') out = jsonToXml(input);
    else if (m==='JSON' && o==='JSON') out = normalizeJsonDynamicOptions(input);
    else if (m==='JSON' && o==='INTELIGENTE') out = jsonToInt(input);
    else if (m==='JSON' && o==='SQL') out = jsonToSql(input);

    else if (m==='XML' && o==='JSON') out = xmlToJson(input);
    else if (m==='XML' && o==='XML') out = prettyXml(normalizeLooseXml(input));
    else if (m==='XML' && o==='INTELIGENTE') out = xmlToInt(input);

    else if (m==='SQL' && o==='JSON') out = sqlToJson(input);

    else throw new Error('Combinação de formatos não suportada.');

    outBox.textContent = out; 
    msg('Conversão concluída.');
  }catch(e){ 
    outBox.textContent=''; 
    msg(e.message, true); 
  }
});

    $('#btnFormat').addEventListener('click', ()=>{
      const m = modeSel.value;
      try{
        if(m==='JSON') inBox.value = prettyJson(inBox.value);
        else inBox.value = prettyXml(normalizeLooseXml(inBox.value));
        msg('Entrada formatada.');
      }catch(e){ msg('Não foi possível formatar a entrada: '+e.message, true); }
    });

    $('#btnCopy').addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(outBox.textContent); msg('Saída copiada.'); }
      catch(e){ msg('Falha ao copiar: '+e.message, true); }
    });

    $('#btnDownload').addEventListener('click', ()=>{
      const o = outSel.value; const isXml = (o==='XML');
      const blob = new Blob([outBox.textContent||''], {type: isXml ? 'application/xml;charset=utf-8' : 'application/json;charset=utf-8'});
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download = isXml ? 'saida.xml' : (o==='INTELIGENTE' ? 'saida.inteligente.json' : 'saida.json');
      a.click(); URL.revokeObjectURL(url);
    });

    $('#btnClear').addEventListener('click', ()=>{
      // limpa campos
      inBox.value = '';
      outBox.textContent = '';
      // limpa mensagens e estilos
      msg('');
      // opcional: remover classe de erro, caso tenha ficado
      msgEl.className = 'muted';
      // foco de volta na entrada
      inBox.focus();
    });

    document.addEventListener('keydown', (e)=>{
      const isMac = navigator.platform.toLowerCase().includes('mac');
      if ((isMac ? e.metaKey : e.ctrlKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        $('#btnClear').click();
      }
    });

    outSel.addEventListener('change', ()=>{
    outTitle.textContent = `Saída (${outSel.value})`;
    msg(outSel.value === 'INTELIGENTE'? 'Saída INTELIGENTE: array de campos no formato [{ id, title, placeholder, type, required, ... }].': '');
    });
    updateUi();

    inBox.addEventListener('input', () => {
    const guess = detectInputFormat(inBox.value);
    if (guess && modeSel.value !== guess) {
      modeSel.value = guess;
      updateUi();
    }
  });

  modeSel.addEventListener('change', ()=>{
  updateUi();
});

  </script>
</body>
</html>
