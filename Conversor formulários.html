<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conversor JSON ⇄ XML (+ INTELIGENTE)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#94a3b8; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--ink); }
    header { padding: 18px 16px; border-bottom: 1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; }
    header h1 { margin:0; font-size: 18px; font-weight: 700; letter-spacing: .2px; }
    main { padding: 16px; max-width: 1100px; margin: 0 auto; }
    .bar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    label { font-size:12px; color: var(--muted); }
    select, button { padding: 8px 12px; border-radius: 10px; background: #0b1220; color: var(--ink); border:1px solid #1f2937; cursor:pointer; font-size: 12px; }
    button:hover, select:hover { border-color:#334155; }
    .accent { border-color: #155e75; background: #04242a; color: #a5f3fc; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    .card { background: var(--panel); border:1px solid #1f2937; border-radius: 12px; overflow:hidden; display:flex; flex-direction:column; min-height: 360px; }
    .card header { background: transparent; border:0; padding: 12px 14px; }
    .card header h2 { margin:0; font-size:14px; color: var(--muted); font-weight:600; }
    textarea { width:100%; flex:1; padding:12px 14px; background: transparent; color: var(--ink); border:0; outline: none; font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; resize:vertical; min-height: 340px; }
    pre { margin:0; padding:12px 14px; white-space: pre-wrap; word-break: break-word; font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; padding: 8px 12px 12px; }
    .muted { color:var(--muted); font-size:12px; margin-top:8px; }
    .error { color:#fecaca; background:#7f1d1d; border:1px solid #ef4444; padding:8px 10px; border-radius:8px; }
    footer { margin-top: 10px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Conversor JSON ⇄ XML (+ INTELIGENTE)</h1>
  </header>
  <main>
    <div class="bar">
      <label for="mode">Entrada:</label>
      <select id="mode" aria-label="Formato de entrada">
        <option value="JSON">JSON</option>
        <option value="XML">XML</option>
      </select>

      <label for="outMode">Saída:</label>
      <select id="outMode" aria-label="Formato de saída">
        <option value="XML">XML</option>
        <option value="JSON">JSON</option>
        <option value="INTELIGENTE">INTELIGENTE</option>
      </select>

      <button id="btnConvert" class="accent">Converter →</button>
      <button id="btnFormat">Formatar entrada</button>
      <button id="btnCopy">Copiar saída</button>
      <button id="btnDownload">Baixar saída</button>
    </div>

    <div class="grid">
      <section class="card">
        <header><h2 id="inTitle">Entrada (JSON)</h2></header>
        <textarea id="inBox" placeholder="Cole aqui seu JSON ou XML..."></textarea>
      </section>
      <section class="card">
        <header><h2 id="outTitle">Saída (XML)</h2></header>
        <pre id="outBox"></pre>
      </section>
    </div>

    <div id="msg" class="muted"></div>

    <footer>
      Regras de mapeamento (resumo):
      <ul>
        <li><strong>JSON → XML</strong>: preserva textos; <code>type: "int"</code> vira <code>&lt;int-numpad-type ...&gt;&lt;/int&gt;</code>; <code>single-select-type</code> vira <code>&lt;single-select-type&gt;&lt;option ...&gt;valor&lt;/option&gt;</code>, mantendo <code>id</code>/<code>selected</code>/<code>machine_status</code>/<code>child_visibility</code>. Metadados do JSON sobem para o &lt;form&gt; quando existirem.</li>
        <li><strong>XML → JSON</strong>: reconstrói <code>{ type: "addForm", data: { form_id, version, title, fields: [...] } }</code>; aceita fechamentos como <code>&lt;int-numpad-type&gt;&lt;/int&gt;</code> e <code>&lt;keyboard-type&gt;&lt;/keyboard&gt;</code>.</li>
        <li><strong>JSON/XML → INTELIGENTE</strong>: produz <em>array</em> de campos. Campos: <code>{ id, title, placeholder, type, required, [min], [max], [options] }</code>. Selects: <code>options</code> vira lista de tuplas <code>[id, label, selected(0/1), machine_status?, child_visibility?]</code>. Sem metadados de formulário.</li>
      </ul>
    </footer>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const modeSel = $('#mode');
    const outSel = $('#outMode');
    const inBox = $('#inBox');
    const outBox = $('#outBox');
    const inTitle = $('#inTitle');
    const outTitle = $('#outTitle');
    const msgEl = $('#msg');

    const msg = (t, isErr=false) => { msgEl.textContent = t; msgEl.className = isErr ? 'error' : 'muted'; };

    // ---------- utils ----------
    function escapeXml(str=""){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;')
        .replace(/\'/g, '&apos;');
    }
    function attr(k,v){ if(v===undefined||v===null||v==='') return ''; return ` ${k}="${escapeXml(String(v))}"`; }
    function prettyXml(xml){
      try{ xml = xml.replace(/\r?\n/g,'').replace(/\t/g,' ').replace(/>(\s*)</g, '>\n<'); let indent=0; const pad=n=>'  '.repeat(n);
        return xml.split(/\n/).map(l=>{ const t=l.trim(); if(!t) return ''; if(t.startsWith('</')) indent=Math.max(0,indent-1); const out=pad(indent)+t; if(/^<[^!?][^>]*[^/]>(?!.*<\/)/.test(t) && !t.startsWith('</')) indent++; return out; }).join('\n'); }catch{ return xml; }
    }
    function prettyJson(obj){ try{ return JSON.stringify(typeof obj==='string'? JSON.parse(obj):obj,null,2); }catch{ return String(obj); } }
    function toNumOrStr(v){ if(v===undefined||v===null) return v; const n=Number(v); return Number.isFinite(n)&&String(n)===String(v).trim()? n : String(v); }

    // ---------- JSON → XML ----------
        function jsonToXml(jsonStr){
      let data;
      try { data = JSON.parse(jsonStr); }
      catch (e) { throw new Error('JSON inválido: ' + e.message); }
    
      const root = data?.data?.fields ? data.data : data;
      if (!root || !Array.isArray(root.fields)) {
        throw new Error('Estrutura inesperada: não encontrei `fields`.');
      }
    
      // --- cabeçalho do <form> conforme sua regra ---
      const formId   = root.form_id ?? root.id ?? '';
      const version  = root.version ?? '';
      const vDigits  = String(version).replace(/\D/g, '');           // só números
      const clientId = (vDigits.slice(0, 4) || '0000');              // 4 primeiros dígitos
    
      let xml = `<?xml version="1.0"?>\n` +
                `<form id="${escapeXml(formId)}" position="1" version="${escapeXml(version)}" client_id="${escapeXml(clientId)}" deprecated="false">`;
    
      // (opcional) manter título como elemento filho, não como atributo
      if (root.title !== undefined) {
        xml += `\n  <title>${escapeXml(String(root.title))}</title>`;
      }
    
      // helper para dígitos do max (int)
      const digitsFromMax = (maxVal)=>{
        if(!Number.isFinite(maxVal) || maxVal <= 0) return undefined;
        return String(Math.floor(maxVal)).length;
      };
    
      for (const f of root.fields){
        const req = !!f.required;
        const title = String(f.title ?? '');
        const placeholder = String(f.placeholder ?? f.default ?? '');
    
        xml += `\n  <item id="${escapeXml(f.id)}" required="${req ? 'true' : 'false'}">`;
        xml += `\n    <title>${escapeXml(title)}</title>`;
        if (placeholder) xml += `\n    <default>${escapeXml(placeholder)}</default>`;
    
        if (f.type === 'int'){
          const minVal = Number.isFinite(f.min) ? f.min : undefined;
          const maxVal = Number.isFinite(f.max) ? f.max : undefined;
          const maxIntLen = Number.isFinite(maxVal) ? digitsFromMax(maxVal) : undefined;
          xml += `\n    <int-numpad-type${attr('max-int-len', maxIntLen ?? 8)}${attr('min-int-val', minVal)}${attr('max-int-val', maxVal)}></int-numpad-type>`;
        } else if (f.type === 'single-select-type' || f.type === 'single-select' ||
                   f.type === 'multi-select-type'  || f.type === 'multi-select'){
          // usa sempre o mesmo contêiner; se você quiser separar multi/single em tags distintas, dá pra trocar aqui
          xml += `\n    <single-select-type>`;
          const options = Array.isArray(f.options) ? f.options : [];
          for (const o of options){
            // aceita tuplas (INTELIGENTE) ou objetos
            if (Array.isArray(o)){
              const [oid, label, selected, machine_status, child_visibility] = o;
              xml += `\n      <option${attr('id', oid)}${attr('selected', selected ? 'true':'false')}${attr('machine_status', machine_status)}${attr('child_visibility', child_visibility)}>${escapeXml(label ?? '')}</option>`;
            } else {
              const label = o.value ?? o.label ?? '';
              xml += `\n      <option${attr('id', o.id)}${attr('selected', o.selected ? 'true':'false')}${attr('machine_status', o.machine_status)}${attr('child_visibility', o.child_visibility)}>${escapeXml(label)}</option>`;
            }
          }
          xml += `\n    </single-select-type>`;
        } else {
          const maxTextLen = Number.isFinite(f.max) ? f.max : undefined;
          xml += `\n    <keyboard-type${attr('max-text-len', maxTextLen)}></keyboard-type>`;
        }
    
        xml += `\n  </item>`;
      }
    
      xml += `\n</form>`;
      return prettyXml(xml);
    }
    // ---------- XML → JSON (objeto) ----------
    function normalizeLooseXml(str){
      return str
        .replace(/<int-numpad-type([^>]*)>\s*<\/int>/gi, '<int-numpad-type$1></int-numpad-type>')
        .replace(/<keyboard-type([^>]*)>\s*<\/keyboard>/gi, '<keyboard-type$1></keyboard-type>');
    }
    function xmlToJsonObject(xmlStr){
      const clean = normalizeLooseXml(xmlStr);
      const doc = new DOMParser().parseFromString(clean, 'application/xml');
      const perr = doc.querySelector('parsererror'); if(perr) throw new Error('XML inválido: ' + perr.textContent.replace(/\s+/g,' ').trim());
      const form = doc.querySelector('form'); if(!form) throw new Error('Não encontrei <form> no XML.');

      const data = {};
      data.form_id = toNumOrStr(form.getAttribute('id'));
      data.version = toNumOrStr(form.getAttribute('version'));
      ['color','machine_status','operador_status','operator_status','form_type'].forEach(k=>{ const v=form.getAttribute(k); if(v!==null) data[k]=toNumOrStr(v); });
      const ot=form.getAttribute('operator_types'); if(ot) data.operator_types = ot.split(',').map(s=>toNumOrStr(s.trim()));
      const osa=form.getAttribute('operator_statuses_allowed'); if(osa) data.operator_statuses_allowed = osa.split(',').map(s=>toNumOrStr(s.trim()));

      const titleEl = form.querySelector(':scope > title'); if(titleEl) data.title = titleEl.textContent || '';

      data.fields = [];
      form.querySelectorAll(':scope > item').forEach(item=>{
        const f = {};
        f.id = toNumOrStr(item.getAttribute('id'));
        f.required = String(item.getAttribute('required')).toLowerCase() === 'true';
        const t=item.querySelector(':scope > title'); if(t) f.title = t.textContent || '';
        const d=item.querySelector(':scope > default'); if(d) f.placeholder = d.textContent || '';

        const intNode = item.querySelector(':scope > int-numpad-type');
        const selNode = item.querySelector(':scope > single-select-type');
        const keyNode = item.querySelector(':scope > keyboard-type');

        if(selNode){
          f.type = 'single-select-type'; f.options = [];
          selNode.querySelectorAll('option').forEach(op=>{
            const o={};
            o.id = toNumOrStr(op.getAttribute('id'));
            const sel=(op.getAttribute('selected')||'').toLowerCase(); o.selected = sel==='true'||sel==='1'||sel==='yes';
            const ms=op.getAttribute('machine_status'); if(ms!==null) o.machine_status = toNumOrStr(ms);
            const cv=op.getAttribute('child_visibility'); if(cv!==null) o.child_visibility = toNumOrStr(cv);
            o.value = op.textContent || '';
            f.options.push(o);
          });
        } else if(intNode){
          f.type = 'int';
          const mil=intNode.getAttribute('min-int-val'); const mal=intNode.getAttribute('max-int-val'); const mlen=intNode.getAttribute('max-int-len');
          if(mil!==null) f.min = toNumOrStr(mil); if(mal!==null) f.max = toNumOrStr(mal);
          if(mlen && mal===null){ const n=Number(mlen); if(Number.isFinite(n)&&n>0&&n<=15){ f.max = Number('9'.repeat(n)); } }
        } else if(keyNode){
          f.type = 'keyboard-type'; const mtl=keyNode.getAttribute('max-text-len'); if(mtl!==null) f.max = toNumOrStr(mtl);
        } else { f.type = 'keyboard-type'; }

        data.fields.push(f);
      });

      return { type: 'addForm', data };
    }
    function xmlToJson(xmlStr){ return prettyJson(xmlToJsonObject(xmlStr)); }

    // ---------- JSON/XML → INTELIGENTE ----------
    function mapFieldToInt(f){
      // normaliza tipos compatíveis
      const isSingle = (f.type === 'single-select-type' || f.type === 'single-select');
      const isMulti  = (f.type === 'multi-select-type'  || f.type === 'multi-select');
    
      const out = {
        id: f.id,
        placeholder: f.placeholder ?? '',
        title: f.title ?? '',
        type: isSingle ? 'single-select' : (isMulti ? 'multi-select' : (f.type || '')),
        required: !!f.required
      };
    
      // limites numéricos
      if (out.type === 'int'){
        if (Number.isFinite(f.min)) out.min = f.min;
        if (Number.isFinite(f.max)) out.max = f.max;
      }
    
      // mapeia opções (single e multi)
      if ((isSingle || isMulti) && Array.isArray(f.options)){
        out.options = f.options.map(op => {
          // já é tupla INTELIGENTE
          if (Array.isArray(op)) return op;
    
          // objeto -> [id, label, selected(0/1), machine_status?, child_visibility?]
          const tuple = [];
          tuple.push(op.id);
          tuple.push(op.value ?? op.label ?? '');
          tuple.push(op.selected ? 1 : 0);
          if (op.machine_status !== undefined) tuple.push(op.machine_status);
          if (op.child_visibility !== undefined) tuple.push(op.child_visibility);
          return tuple;
        });
      }
    
      return out;
    }
    
    function dataToInt(data){
      if(!data || !Array.isArray(data.fields)) {
        throw new Error('Estrutura inesperada: não encontrei `fields`.');
      }
      return data.fields.map(mapFieldToInt);
    }
    
    function jsonToInt(jsonStr){
      let obj;
      try { obj = JSON.parse(jsonStr); }
      catch(e){ throw new Error('JSON inválido: ' + e.message); }
      const root = obj?.data?.fields ? obj.data : obj;
      const arr = dataToInt(root);
      return prettyJson(arr);
    }
    
    function xmlToInt(xmlStr){
      const obj = xmlToJsonObject(xmlStr); // { type, data }
      const arr = dataToInt(obj.data);
      return prettyJson(arr);
    }

    // ---------- UI ----------
    function updateUi(){
      const m = modeSel.value; const o = outSel.value;
      inTitle.textContent = `Entrada (${m})`;
      outTitle.textContent = `Saída (${o})`;
      inBox.placeholder = m==='JSON' ? 'Cole aqui seu JSON...' : 'Cole aqui seu XML...';
      // se entrada for JSON, default saída XML; se entrada for XML, default saída JSON (não forçar se usuário já escolheu INTELIGENTE)
      if(o==='INTELIGENTE') return; // respeita escolha
      outSel.value = (m==='JSON') ? 'XML' : 'JSON';
      outTitle.textContent = `Saída (${outSel.value})`;
      outBox.textContent = '';
      msg('');
    }

    $('#btnConvert').addEventListener('click', ()=>{
      try{
        const m = modeSel.value; const o = outSel.value; const input = inBox.value;
        let out='';
        if(m==='JSON' && o==='XML') out = jsonToXml(input);
        else if(m==='JSON' && o==='JSON') out = prettyJson(input);
        else if(m==='JSON' && o==='INTELIGENTE') out = jsonToInt(input);
        else if(m==='XML' && o==='JSON') out = xmlToJson(input);
        else if(m==='XML' && o==='XML') out = prettyXml(normalizeLooseXml(input));
        else if(m==='XML' && o==='INTELIGENTE') out = xmlToInt(input);
        else throw new Error('Combinação de formatos não suportada.');
        outBox.textContent = out; msg('Conversão concluída.');
      }catch(e){ outBox.textContent=''; msg(e.message, true); }
    });

    $('#btnFormat').addEventListener('click', ()=>{
      const m = modeSel.value;
      try{
        if(m==='JSON') inBox.value = prettyJson(inBox.value);
        else inBox.value = prettyXml(normalizeLooseXml(inBox.value));
        msg('Entrada formatada.');
      }catch(e){ msg('Não foi possível formatar a entrada: '+e.message, true); }
    });

    $('#btnCopy').addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(outBox.textContent); msg('Saída copiada.'); }
      catch(e){ msg('Falha ao copiar: '+e.message, true); }
    });

    $('#btnDownload').addEventListener('click', ()=>{
      const o = outSel.value; const isXml = (o==='XML');
      const blob = new Blob([outBox.textContent||''], {type: isXml ? 'application/xml;charset=utf-8' : 'application/json;charset=utf-8'});
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download = isXml ? 'saida.xml' : (o==='INTELIGENTE' ? 'saida.inteligente.json' : 'saida.json');
      a.click(); URL.revokeObjectURL(url);
    });

    outSel.addEventListener('change', ()=>{
    outTitle.textContent = `Saída (${outSel.value})`;
    msg(outSel.value === 'INTELIGENTE'? 'Saída INTELIGENTE: array de campos no formato [{ id, title, placeholder, type, required, ... }].': '');
    });
    updateUi();
  </script>
</body>
</html>




