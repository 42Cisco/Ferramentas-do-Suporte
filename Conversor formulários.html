<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Conversor JSON ⇄ XML (+ INTELIGENTE)</title>
  <style>
    :root { --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#94a3b8; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color: var(--ink); }
    header { padding: 18px 16px; border-bottom: 1px solid #1f2937; display:flex; align-items:center; justify-content:space-between; }
    header h1 { margin:0; font-size: 18px; font-weight: 700; letter-spacing: .2px; }
    main { padding: 16px; max-width: 1100px; margin: 0 auto; }
    .bar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom: 10px; }
    label { font-size:12px; color: var(--muted); }
    select, button { padding: 8px 12px; border-radius: 10px; background: #0b1220; color: var(--ink); border:1px solid #1f2937; cursor:pointer; font-size: 12px; }
    button:hover, select:hover { border-color:#334155; }
    .accent { border-color: #155e75; background: #04242a; color: #a5f3fc; }
    .grid { display:grid; gap:12px; grid-template-columns: 1fr 1fr; }
    .card { background: var(--panel); border:1px solid #1f2937; border-radius: 12px; overflow:hidden; display:flex; flex-direction:column; min-height: 360px; }
    .card header { background: transparent; border:0; padding: 12px 14px; }
    .card header h2 { margin:0; font-size:14px; color: var(--muted); font-weight:600; }
    textarea { width:100%; flex:1; padding:12px 14px; background: transparent; color: var(--ink); border:0; outline: none; font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; resize:vertical; min-height: 340px; }
    pre { margin:0; padding:12px 14px; white-space: pre-wrap; word-break: break-word; font: 12px/1.45 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; padding: 8px 12px 12px; }
    .muted { color:var(--muted); font-size:12px; margin-top:8px; }
    .error { color:#fecaca; background:#7f1d1d; border:1px solid #ef4444; padding:8px 10px; border-radius:8px; }
    footer { margin-top: 10px; color: var(--muted); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <h1>Conversor JSON ⇄ XML (+ INTELIGENTE)</h1>
  </header>
  <main>
    <div class="bar">
      <label for="mode">Entrada:</label>
      <select id="mode" aria-label="Formato de entrada">
        <option value="JSON">JSON</option>
        <option value="XML">XML</option>
      </select>

      <label for="outMode">Saída:</label>
      <select id="outMode" aria-label="Formato de saída">
        <option value="XML">XML</option>
        <option value="JSON">JSON</option>
        <option value="INTELIGENTE">INTELIGENTE</option>
      </select>

      <button id="btnConvert" class="accent">Converter →</button>
      <button id="btnFormat">Formatar entrada</button>
      <button id="btnCopy">Copiar saída</button>
      <button id="btnDownload">Baixar saída</button>
      <button id="btnClear" aria-label="Limpar entrada e saída">Limpar</button>
    </div>

    <div class="grid">
      <section class="card">
        <header><h2 id="inTitle">Entrada (JSON)</h2></header>
        <textarea id="inBox" placeholder="Cole aqui seu JSON ou XML..."></textarea>
      </section>
      <section class="card">
        <header><h2 id="outTitle">Saída (XML)</h2></header>
        <pre id="outBox"></pre>
      </section>
    </div>

    <div id="msg" class="muted"></div>

    <footer>
      Regras de mapeamento (resumo):
      <ul>
        <li><strong>JSON → XML</strong>: preserva textos; <code>type: "int"</code> vira <code>&lt;int-numpad-type ...&gt;&lt;/int&gt;</code>; <code>single-select-type</code> vira <code>&lt;single-select-type&gt;&lt;option ...&gt;valor&lt;/option&gt;</code>, mantendo <code>id</code>/<code>selected</code>/<code>machine_status</code>/<code>child_visibility</code>. Metadados do JSON sobem para o &lt;form&gt; quando existirem.</li>
        <li><strong>XML → JSON</strong>: reconstrói <code>{ type: "addForm", data: { form_id, version, title, fields: [...] } }</code>; aceita fechamentos como <code>&lt;int-numpad-type&gt;&lt;/int&gt;</code> e <code>&lt;keyboard-type&gt;&lt;/keyboard&gt;</code>.</li>
        <li><strong>JSON/XML → INTELIGENTE</strong>: produz <em>array</em> de campos. Campos: <code>{ id, title, placeholder, type, required, [min], [max], [options] }</code>. Selects: <code>options</code> vira lista de tuplas <code>[id, label, selected(0/1), machine_status?, child_visibility?]</code>. Sem metadados de formulário.</li>
      </ul>
    </footer>
  </main>

  <script>
    const $ = (sel) => document.querySelector(sel);
    const modeSel = $('#mode');
    const outSel = $('#outMode');
    const inBox = $('#inBox');
    const outBox = $('#outBox');
    const inTitle = $('#inTitle');
    const outTitle = $('#outTitle');
    const msgEl = $('#msg');

    const msg = (t, isErr=false) => { msgEl.textContent = t; msgEl.className = isErr ? 'error' : 'muted'; };

    // ---------- utils ----------
    function escapeXml(str=""){
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\"/g, '&quot;')
        .replace(/\'/g, '&apos;');
    }
    function attr(k, v){
  if (v === undefined || v === null || v === '') return '';
  return ` ${k}="${escapeXml(String(v))}"`;
}

function prettyXml(xml){
  try{
    xml = xml.replace(/\r?\n/g,'').replace(/\t/g,' ');

    // --- proteger pares compactos: ficam "><" sem quebra ---
    const PROTECT = '__NO_NL__';
    const COMPACT_CLOSE = '(?:int-numpad-type|keyboard-type)'; // adicione mais tags aqui se quiser
    xml = xml.replace(new RegExp('>\\s*(?=</' + COMPACT_CLOSE + '>)', 'g'), PROTECT);

    // quebras normais entre tags
    xml = xml.replace(/>(\s*)</g, '>\n<');

    // restaura os trechos protegidos sem quebra
    xml = xml.replace(new RegExp(PROTECT, 'g'), '><');

    let indent = 0;
    const pad = n => '  '.repeat(n);

    return xml.split('\n').map(l => {
      const t = l.trim();
      if (!t) return '';
      if (t.startsWith('</')) indent = Math.max(0, indent - 1);
      const out = pad(indent) + t;
      if (/^<[^!?][^>]*[^/]>(?!.*<\/)/.test(t) && !t.startsWith('</')) indent++;
      return out;
    }).join('\n');
  } catch {
    return xml;
  }
}

function prettyJson(obj){
  try{ return JSON.stringify(typeof obj==='string' ? JSON.parse(obj) : obj, null, 2); }
  catch{ return String(obj); }
}

function toNumOrStr(v){
  if (v === undefined || v === null) return v;
  const n = Number(v);
  return Number.isFinite(n) && String(n) === String(v).trim() ? n : String(v);
}

    // ---------- JSON → XML ----------
        function jsonToXml(jsonStr){
      let data;
      try { data = JSON.parse(jsonStr); }
      catch (e) { throw new Error('JSON inválido: ' + e.message); }
    
      const root = data?.data?.fields ? data.data : data;
      if (!root || !Array.isArray(root.fields)) {
        throw new Error('Estrutura inesperada: não encontrei `fields`.');
      }
    
      // --- cabeçalho do <form> conforme sua regra ---
      const formId   = root.form_id ?? root.id ?? '';
      const version  = root.version ?? '';
      const vDigits  = String(version).replace(/\D/g, '');           // só números
      const clientId = (vDigits.slice(0, 4) || '0000');              // 4 primeiros dígitos
    
      let xml = `<?xml version="1.0"?>\n` +
                `<form id="${escapeXml(formId)}" position="1" version="${escapeXml(version)}" client_id="${escapeXml(clientId)}" deprecated="false">`;
    
      // (opcional) manter título como elemento filho, não como atributo
      if (root.title !== undefined) {
        xml += `\n  <title>${escapeXml(String(root.title))}</title>`;
      }
    
      // helper para dígitos do max (int)
      const digitsFromMax = (maxVal)=>{
        if(!Number.isFinite(maxVal) || maxVal <= 0) return undefined;
        return String(Math.floor(maxVal)).length;
      };
    
      for (const f of root.fields){
        const req = !!f.required;
        const title = String(f.title ?? '');
        const placeholder = String(f.placeholder ?? f.default ?? '');
    
        xml += `\n  <item id="${escapeXml(f.id)}" required="${req ? 'true' : 'false'}">`;
        xml += `\n    <title>${escapeXml(title)}</title>`;
        if (placeholder) xml += `\n    <default>${escapeXml(placeholder)}</default>`;
    
        if (f.type === 'int'){
          const minVal = Number.isFinite(f.min) ? f.min : undefined;
          const maxVal = Number.isFinite(f.max) ? f.max : undefined;
          const maxIntLen = Number.isFinite(maxVal) ? digitsFromMax(maxVal) : undefined;
          xml += `\n    <int-numpad-type${attr('max-int-len', maxIntLen ?? 8)}${attr('min-int-val', minVal)}${attr('max-int-val', maxVal)}></int-numpad-type>`;
        } else if (f.type === 'single-select-type' || f.type === 'single-select' ||
                   f.type === 'multi-select-type'  || f.type === 'multi-select'){
          // usa sempre o mesmo contêiner; se você quiser separar multi/single em tags distintas, dá pra trocar aqui
          xml += `\n    <single-select-type>`;
          const options = Array.isArray(f.options) ? f.options : [];
          for (const o of options){
            // aceita tuplas (INTELIGENTE) ou objetos
            if (Array.isArray(o)){
              const [oid, label, selected, machine_status, child_visibility] = o;
              xml += `\n      <option${attr('id', oid)}${attr('selected', selected ? 'true':'false')}${attr('machine_status', machine_status)}${attr('child_visibility', child_visibility)}>${escapeXml(label ?? '')}</option>`;
            } else {
              const label = o.value ?? o.label ?? '';
              xml += `\n      <option${attr('id', o.id)}${attr('selected', o.selected ? 'true':'false')}${attr('machine_status', o.machine_status)}${attr('child_visibility', o.child_visibility)}>${escapeXml(label)}</option>`;
            }
          }
          xml += `\n    </single-select-type>`;
        } else {
          const maxTextLen = Number.isFinite(f.max) ? f.max : undefined;
          xml += `\n    <keyboard-type${attr('max-text-len', maxTextLen)}></keyboard-type>`;
        }
    
        xml += `\n  </item>`;
      }
    
      xml += `\n</form>`;
      return prettyXml(xml);
    }
    // ---------- XML → JSON (objeto) ----------
    function normalizeLooseXml(str){
      return str
        .replace(/<int-numpad-type([^>]*)>\s*<\/int>/gi, '<int-numpad-type$1></int-numpad-type>')
        .replace(/<keyboard-type([^>]*)>\s*<\/keyboard>/gi, '<keyboard-type$1></keyboard-type>');
    }

    // ====== CABEÇALHOS PADRÃO (apenas para XML -> JSON) ======

    const JSON_HEADERS_BY_FORM_ID = {
      4101:   { form_type: "breakdown",        title: "AGUARDANDO MANUTENÇÃO",                 machine_status: 4,  operador_status: 3,  operator_types: [1,2,3,4,11,18,19], operator_statuses_allowed: [3] },
      101004: { form_type: "workLunch",        title: "ALMOÇO",                                 machine_status: 11, operador_status: -1, operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      11310:  { form_type: "appropriation",    title: "APROPRIACAO DO EQUIPAMENTO",            machine_status: -1, operador_status: 2,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [1], color: "03A9F4" },
      12120:  { form_type: "checklist",        title: "CHECKLIST",                              machine_status: 6,  operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [2] },
      10403:  { form_type: "expropriation",    title: "DESAPROPRIACAO DO EQUIPAMENTO",         machine_status: 2,  operador_status: 1,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      7720:   { form_type: "movingFull",       title: "DESLOCANDO CARREGADO",                  machine_status: 31, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      7520:   { form_type: "movingEmpty",      title: "DESLOCANDO VAZIO",                      machine_status: 29, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      5205:   { form_type: "end_supply",       title: "FIM ABASTECIMENTO/LUBRIFICAÇÃO",        machine_status: 2,  operador_status: -1, operator_types: [1,2,3,4,8,11,18],   operator_statuses_allowed: [3,4] },
      4303:   { form_type: "end_maintenance",  title: "FIM DE MANUTENÇÃO",                      machine_status: -1, operador_status: 3,  operator_types: [1,2,3,11,18,19],    operator_statuses_allowed: [4] },
      51001:  { form_type: "start_supply",     title: "INÍCIO ABASTECIMENTO / LUBRIFICAÇÃO",   machine_status: -1, operador_status: -1, operator_types: [1,2,3,4,8,11,18],   operator_statuses_allowed: [3,4] },
      7021:   { form_type: "initLoad",         title: "INÍCIO DE CARREGAMENTO",                machine_status: 30, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      7121:   { form_type: "initUnload",       title: "INÍCIO DE DESCARREGAMENTO",             machine_status: 32, operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      4201:   { form_type: "start_maintenance",title: "INÍCIO DE MANUTENÇÃO",                  machine_status: 5,  operador_status: 4,  operator_types: [1,2,3,11,18,19],    operator_statuses_allowed: [3] },
      101005: { form_type: "workBreak",        title: "INTERVALO",                              machine_status: 39, operador_status: -1, operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
      101080: { form_type: "operational_stop", title: "PARADA OPERACIONAL",                    machine_status: 6,  operador_status: 3,  operator_types: [1,2,4,11,18],       operator_statuses_allowed: [3] },
    };

    // completa/ajusta o cabeçalho conforme o form_id
    function applyJsonHeaderForForm(data){
      const fid = Number(data.form_id);
      const tpl = JSON_HEADERS_BY_FORM_ID[fid];
      if (!tpl) return data;

      const title = (data.title !== undefined && String(data.title).trim() !== '')
        ? data.title
        : tpl.title;

      const out = {
        form_type: tpl.form_type,
        form_id: data.form_id,
        version: data.version,
        title,
        machine_status: tpl.machine_status,
        operador_status: tpl.operador_status,
        operator_types: Array.isArray(tpl.operator_types) ? [...tpl.operator_types] : [],
        operator_statuses_allowed: Array.isArray(tpl.operator_statuses_allowed) ? [...tpl.operator_statuses_allowed] : [],
        fields: data.fields
      };
      if (tpl.color) out.color = tpl.color;
      return out;
    }

    // ordena o cabeçalho na ordem desejada
    function orderJsonDataKeys(d){
      const ordered = {
        form_type: d.form_type,
        form_id: d.form_id,
        version: d.version,
        title: d.title,
      };
      if (d.color !== undefined) ordered.color = d.color;
      Object.assign(ordered, {
        machine_status: d.machine_status,
        operador_status: d.operador_status,
        operator_types: d.operator_types,
        operator_statuses_allowed: d.operator_statuses_allowed,
        fields: d.fields
      });
      return ordered;
    }

    function xmlToJsonObject(xmlStr){
      const clean = normalizeLooseXml(xmlStr);
      const doc = new DOMParser().parseFromString(clean, 'application/xml');
      const perr = doc.querySelector('parsererror'); 
      if(perr) throw new Error('XML inválido: ' + perr.textContent.replace(/\s+/g,' ').trim());

      const form = doc.querySelector('form'); 
      if(!form) throw new Error('Não encontrei <form> no XML.');

      const data = {};
      data.form_id = toNumOrStr(form.getAttribute('id'));
      data.version = toNumOrStr(form.getAttribute('version'));

      const titleEl = form.querySelector(':scope > title');
      if(titleEl) data.title = titleEl.textContent || '';

      data.fields = [];
      form.querySelectorAll(':scope > item').forEach(item=>{
        const f = {};
        f.id = toNumOrStr(item.getAttribute('id'));
        f.required = String(item.getAttribute('required')).toLowerCase() === 'true';

        const t=item.querySelector(':scope > title'); 
        if(t) f.title = t.textContent || '';

        const dft=item.querySelector(':scope > default'); 
        if(dft) f.placeholder = dft.textContent || '';

        const intNode = item.querySelector(':scope > int-numpad-type');
        const selNode = item.querySelector(':scope > single-select-type, :scope > multi-select-type');
        const keyNode = item.querySelector(':scope > keyboard-type');

        if (selNode){
          const isMulti = selNode.tagName.toLowerCase() === 'multi-select-type';
          f.type = isMulti ? 'multi-select-type' : 'single-select-type';
          f.options = [];
          selNode.querySelectorAll('option').forEach(op=>{
            const o = {};
            o.id = toNumOrStr(op.getAttribute('id'));
            const sel=(op.getAttribute('selected')||'').toLowerCase();
            o.value = op.textContent || '';
            o.selected = (sel==='true'||sel==='1'||sel==='yes');
            const ms=op.getAttribute('machine_status'); if(ms!==null) o.machine_status = toNumOrStr(ms);
            const cv=op.getAttribute('child_visibility'); if(cv!==null) o.child_visibility = toNumOrStr(cv);
            f.options.push(o);
          });

          // Regra especial: TURNO
          if ((f.title || '').trim().toUpperCase() === 'TURNO'){
            f.type = 'single-select';
            f.work_shift = true;
          }

        } else if (intNode){
          f.type = 'int';
          const mil=intNode.getAttribute('min-int-val');
          const mal=intNode.getAttribute('max-int-val');
          const mlen=intNode.getAttribute('max-int-len');
          if(mil!==null) f.min = toNumOrStr(mil);
          if(mal!==null) f.max = toNumOrStr(mal);
          if(mlen && mal===null){
            const n=Number(mlen);
            if(Number.isFinite(n)&&n>0&&n<=15){ f.max = Number('9'.repeat(n)); }
          }
        } else if (keyNode){
          f.type = 'keyboard-type';
          const mtl=keyNode.getAttribute('max-text-len'); 
          if(mtl!==null) f.max = toNumOrStr(mtl);
        } else {
          f.type = 'keyboard-type';
        }

        data.fields.push(f);
      });

      // aplica cabeçalho e ordena antes de retornar
      const normalized = applyJsonHeaderForForm(data);
      const ordered = orderJsonDataKeys(normalized);
      return { type: 'addForm', data: ordered };
    }

    function xmlToJson(xmlStr){
      return prettyJson(xmlToJsonObject(xmlStr));
    }

    // ---------- JSON/XML → INTELIGENTE ----------
    function mapFieldToInt(f){
      // normaliza tipos compatíveis
      const isSingle = (f.type === 'single-select-type' || f.type === 'single-select');
      const isMulti  = (f.type === 'multi-select-type'  || f.type === 'multi-select');
    
      const out = {
        id: f.id,
        placeholder: f.placeholder ?? '',
        title: f.title ?? '',
        type: isSingle ? 'single-select' : (isMulti ? 'multi-select' : (f.type || '')),
        required: !!f.required
      };
    
      // limites numéricos
      if (out.type === 'int'){
        if (Number.isFinite(f.min)) out.min = f.min;
        if (Number.isFinite(f.max)) out.max = f.max;
      }
    
      // mapeia opções (single e multi)
      if ((isSingle || isMulti) && Array.isArray(f.options)){
        out.options = f.options.map(op => {
          // já é tupla INTELIGENTE
          if (Array.isArray(op)) return op;
    
          // objeto -> [id, label, selected(0/1), machine_status?, child_visibility?]
          const tuple = [];
          tuple.push(op.id);
          tuple.push(op.value ?? op.label ?? '');
          tuple.push(op.selected ? 1 : 0);
          if (op.machine_status !== undefined) tuple.push(op.machine_status);
          if (op.child_visibility !== undefined) tuple.push(op.child_visibility);
          return tuple;
        });
      }
    
      return out;
    }
    
    function dataToInt(data){
      if(!data || !Array.isArray(data.fields)) {
        throw new Error('Estrutura inesperada: não encontrei `fields`.');
      }
      return data.fields.map(mapFieldToInt);
    }
    
    function jsonToInt(jsonStr){
      let obj;
      try { obj = JSON.parse(jsonStr); }
      catch(e){ throw new Error('JSON inválido: ' + e.message); }
      const root = obj?.data?.fields ? obj.data : obj;
      const arr = dataToInt(root);
      return prettyJson(arr);
    }
    
    function xmlToInt(xmlStr){
      const obj = xmlToJsonObject(xmlStr); // { type, data }
      const arr = dataToInt(obj.data);
      return prettyJson(arr);
    }

    // ---------- UI ----------
    function updateUi(){
      const m = modeSel.value; const o = outSel.value;
      inTitle.textContent = `Entrada (${m})`;
      outTitle.textContent = `Saída (${o})`;
      inBox.placeholder = m==='JSON' ? 'Cole aqui seu JSON...' : 'Cole aqui seu XML...';
      // se entrada for JSON, default saída XML; se entrada for XML, default saída JSON (não forçar se usuário já escolheu INTELIGENTE)
      if(o==='INTELIGENTE') return; // respeita escolha
      outSel.value = (m==='JSON') ? 'XML' : 'JSON';
      outTitle.textContent = `Saída (${outSel.value})`;
      outBox.textContent = '';
      msg('');
    }

    $('#btnConvert').addEventListener('click', ()=>{
      try{
        const m = modeSel.value; const o = outSel.value; const input = inBox.value;
        let out='';
        if(m==='JSON' && o==='XML') out = jsonToXml(input);
        else if(m==='JSON' && o==='JSON') out = prettyJson(input);
        else if(m==='JSON' && o==='INTELIGENTE') out = jsonToInt(input);
        else if(m==='XML' && o==='JSON') out = xmlToJson(input);
        else if(m==='XML' && o==='XML') out = prettyXml(normalizeLooseXml(input));
        else if(m==='XML' && o==='INTELIGENTE') out = xmlToInt(input);
        else throw new Error('Combinação de formatos não suportada.');
        outBox.textContent = out; msg('Conversão concluída.');
      }catch(e){ outBox.textContent=''; msg(e.message, true); }
    });

    $('#btnFormat').addEventListener('click', ()=>{
      const m = modeSel.value;
      try{
        if(m==='JSON') inBox.value = prettyJson(inBox.value);
        else inBox.value = prettyXml(normalizeLooseXml(inBox.value));
        msg('Entrada formatada.');
      }catch(e){ msg('Não foi possível formatar a entrada: '+e.message, true); }
    });

    $('#btnCopy').addEventListener('click', async ()=>{
      try{ await navigator.clipboard.writeText(outBox.textContent); msg('Saída copiada.'); }
      catch(e){ msg('Falha ao copiar: '+e.message, true); }
    });

    $('#btnDownload').addEventListener('click', ()=>{
      const o = outSel.value; const isXml = (o==='XML');
      const blob = new Blob([outBox.textContent||''], {type: isXml ? 'application/xml;charset=utf-8' : 'application/json;charset=utf-8'});
      const url = URL.createObjectURL(blob); const a=document.createElement('a');
      a.href=url; a.download = isXml ? 'saida.xml' : (o==='INTELIGENTE' ? 'saida.inteligente.json' : 'saida.json');
      a.click(); URL.revokeObjectURL(url);
    });

    $('#btnClear').addEventListener('click', ()=>{
      // limpa campos
      inBox.value = '';
      outBox.textContent = '';
      // limpa mensagens e estilos
      msg('');
      // opcional: remover classe de erro, caso tenha ficado
      msgEl.className = 'muted';
      // foco de volta na entrada
      inBox.focus();
    });

    document.addEventListener('keydown', (e)=>{
      const isMac = navigator.platform.toLowerCase().includes('mac');
      if ((isMac ? e.metaKey : e.ctrlKey) && e.key.toLowerCase() === 'k') {
        e.preventDefault();
        $('#btnClear').click();
      }
    });

    outSel.addEventListener('change', ()=>{
    outTitle.textContent = `Saída (${outSel.value})`;
    msg(outSel.value === 'INTELIGENTE'? 'Saída INTELIGENTE: array de campos no formato [{ id, title, placeholder, type, required, ... }].': '');
    });
    updateUi();
  </script>
</body>
</html>
